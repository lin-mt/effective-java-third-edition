## 了解和使用类库

&emsp;&emsp;假设你希望产生位于 0 和某个上界之间的随机整数。面对这个常见的任务，许多程序猿会编写如下所示的方法：

```java
// Common but deeply flawed!
static Random rnd = new Random();
static int random(int n) {
    return Math.abs(rnd.nextInt()) % n;
}
```

&emsp;&emsp;这个方法看起来可能不错，但是却有三个缺点。第一个缺点是，如果 n 是一个比较小的 2 的乘方，经过一段相当短的周期之后，它产生的随机序列就会重复。第二个缺点是，如果 n 不是 2 的乘方，那么平均起来，有些数会比其他的数出现得更为频繁。如果 n 比较大，这个影响就会相当的明显。这可以通过下面的程序直观地体现出来，它会产生一百万个指定范围内的随机数，并打印出有多少个数字落在随机数取值范围的前半部分：

```java
public static void main(String[] args) {
    int n = 2 * (Integer.MAX_VALUE / 3);
    int low = 0;
    for (int i = 0; i < 1000000; i++)
        if (random(n) < n/2)
            low++;
    System.out.println(low);
}
```

&emsp;&emsp;如果 random 方法工作正常的话，这个程序打印出来的数将接近一百万的一半，但是如果真正运行这个程序，就会发现它打印出来的数接近于 666666.由 random 方法产生的数字有 2/3 落在随机数取值范围的前半部分。

&emsp;&emsp;random 方法的第三个缺点是，在极少数情况下，它的失败是灾难性的，返回一个落在指定范围之外的数。之所以如此，是因为这个方法试图通过调用 Math.abs，将 rnd.nextInt()返回的值映射为一个非负整数 int。假如 nextInt()返回 Integer.MIN_VALUE，那么 Math.abs 也会返回 Integer.MIN_VALUE，假设 n 不是 2 的乘方，那么取模操作符（%）将返回一个负数。这几乎肯定会使程序失败，而且这种失败很难重现。

&emsp;&emsp;为了编写能修正这三个缺点的 random 方法，有必要了解关于伪随机数生成器、数论和 2 的求补算法的相关知识。幸运的是，你并不需要自己来做这些工作————已经有现成的成果可以为你所用。它被称为 Random.nextInt(int)，你无需关心它如何完成其工作的细节（如果你有强烈的好奇心，可以研究它的文档或者源代码）。具有算法背景的高级工程师已经花了大量的时间来设计、实现和测试这个方法，然后经过这个领域中的专家的审查，以确保它的正确性。然后，标准类库经过 Beta 测试、发行和将近二十年的成千上万程序猿的广泛使用。在这个方法中还没有发现过缺陷，但是，如果将来发现有缺陷，在下一个发行版本中就会修正这些缺陷。**通过使用标准类库，可以充分利用这些编写标准类库的专家的知识，以及在你之前的其他人的使用经验** 。

&emsp;&emsp;从 Java 7 开始，你不应再使用 Random。对于大多数的用法，**选择的随机数生成器现在【首选】是 ThreadLocalRandom** 。它产生更高质量的随机数，而且速度非常快。在我的机器上，它比 Random 快 3.6 倍。对于 fork 连接池和并行流，请使用 SplittableRandom。

&emsp;&emsp;使用这些类库的第二个好处是，不必浪费时间为那些与工作不太相关的问题提供特别的解决方案。就像大多数程序猿一样，应该把时间花在应用程序上，而不是底层的细节上。

&emsp;&emsp;使用标准类库的第三个好处是，它们的性能往往会随着时间的推移而不断提高，无需你做任何努力。因为许多人在使用它们，被当作工业标准在使用，所以，提供这些标准类库的组织有强烈的动机要使它们运行得更快。这些年来，许多 Java 平台类库已经被重新编写了，有时候是重复编写，从而导致性能上有了显著的提高。

&emsp;&emsp;使用库的第四个优点是，它们往往会随着时间的推移而获得【更多的】功能。如果某个类库缺少了某些东西，开发人员社区就会把这些缺点告示出来（the developer community will make it known），并且可能会在后续版本中添加缺少的功能。

&emsp;&emsp;使用标准类库的最后一个好处是，可以使自己的代码融入主流，这样的代码更易容阅读、更容易维护、更容易被大多数的开发人员重用。

&emsp;&emsp;既然有那么多的优点，使用标准类库机制而不选择专门的实现，这显然是符合逻辑的，然而还是有相当一部分的程序猿没有这样做。为什么呢？可能它们并不知道有这些类库机制的存在。**每个主要版本的库中都添加了许多功能，并且可以随时了解这些新增内容** 。每次 Java 平台有重要的发行版本时，会有一个网页说明新的特性。这些网页值得仔细地读一读\[Java8-feat, Java9-feat\]。为了强调这一点，假设你想编写一个程序来打印命令行中指定的 URL 的内容（这大致与 Linux curl 命令相同）。在 Java 9 之前，这段代码有点乏味，但在 Java 9 中，transferTo 方法被添加到 InputStream 中。以下是使用此新方法执行此任务的完整程序：

```java
// Printing the contents of a URL with transferTo, added in Java 9
public static void main(String[] args) throws IOException {
    try (InputStream in = new URL(args[0]).openStream()) {
        in.transferTo(System.out);
    }
}
```

&emsp;&emsp;这些标准类库机制太庞大了，以至于不可能去学习所有的文档\[Java9-api\]，但是**每个程序猿都应该熟悉 java.lang、java.util 和 java.io，以及它们的子包** 。可以根据需要获取其他类库的知识。总结类库的技巧超出了本项的范围，这些技巧多年来一直在增长。

&emsp;&emsp;有几个类库特别值得一提。集合框架和流类库（第 45 项-第 58 项）应该是每个程序猿的基本工具包的一部分，也包括 java.util.concurrent 中的并发实用工具。这个包即包含高级别的并发工具来简化多线程的编程任务，还包含低级别的并发类型，允许专家们自己编写更高级的并发抽象。第 80 和 81 项讨论了 java.util.current 的高级部分。

&emsp;&emsp;有些情况下，一个类库工具并不能满足你的需要。你的需求越是特殊，这种情形就越有可能发生。虽然你的第一个念头应该是使用标准类库，但是，如果你在观察了它们在某些领域所提供的功能之后，确定它不能满足需要，那么就使用替代实现。任何有限的类库集提供的功能总是存在遗漏。如果你无法在 Java 平台库中找到所需要的内容，那么你的下一个选择应该是查看高质量的第三方库，例如 Google 优秀的开源 Guava 库\[Guava\]。如果你在任何适当的类库中都找不到所需要的功能，你可能只能自己实现，别无选择。

&emsp;&emsp;总而言之，不要重新发明轮子。如果你需要做的事情看起来是十分常见的，有可能类库中已经有某个类完成了这样的工作。如果确实是这样，就使用它；如果你不知道是否存在这样的类，就去查一查。一般而言，类库的代码可能比你自己编写的代码更好一些，并且会随着时间的推移不断改进。这并不是在影射你作为一只程序猿的能力。从经济角度的分析表明：类库代码受到的关注远远超过大多数普通程序猿在同样的功能上所能给予的投入。

> - [第 58 项：for-each 循环优先于传统的 for 循环](https://gitee.com/lin-mt/effective-java-third-edition/blob/master/第09章：通用编程/第58项：for-each循环优先于传统的for循环.md)
> - [第 60 项：如果需要精确的答案，请避免使用 float 和 double](https://gitee.com/lin-mt/effective-java-third-edition/blob/master/第09章：通用编程/第60项：如果需要精确的答案，请避免使用float和double.md)
