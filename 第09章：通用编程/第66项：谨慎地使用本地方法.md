## 谨慎地使用本地方法

&emsp;&emsp;Java Native Interface (JNI) 允许Java应用程序可以调用*本地方法（native method）*，所谓本地方法是指使用*本地程序设计语言（native programming languages）*（比如C或者C++）来编写的方法。从历史上看，本地方法主要有三种用途。它们提供了“访问特定于平台的机制”的能力，比如【访问】注册表。它们还提供了访问遗留代码库的能力，从而可以访问遗留数据（legacy data）。最后，本地方法可以通过本地语言，编写应用程序中注重性能的部分，从而提高系统的性能。

&emsp;&emsp;使用本地方法来访问特定于平台的机制是合法的，但这很少是必要的（but it is seldom necessary）：随着Java平台的成熟，它提供了越来越多以前只有在宿主平台上才拥有的特性。例如，在Java 9中添加的进程API，这个API提供了访问操作系统的进程的功能。当Java中没有可用的等效库时，使用本地方法来使用遗留代码也是合法的。

&emsp;&emsp;**不提倡使用本地方法来提高性能的做法** 。在早期的发行版本中（在Java 3之前），这样做往往是很有必要的，但从那时起JVM就变得更快了。对于大多数任务，现在可以在Java中获得与之相当的性能。例如，当在1.1版中添加java.math时，BigInteger依赖于用C编写的一个快速的多精度算术库。在Java 3中，BigInteger在Java中重新实现，并仔细调整到比原来【依赖于】本地【库】实现【的版本】运行得更快的程度。

&emsp;&emsp;这个故事的一个令人遗憾的结论是BigInteger从那以后变化不大，除了Java 8中大数字的快速乘法。在那段时间，本机【代码】库的【优化】工作仍在继续，特别是GNU多精度算术库（GMP）。现在需要真正高性能多精度算术的Java程序猿通过本地方法\[Blum14\]使用GMP是合理的。

&emsp;&emsp;使用本地方法具有严重的缺点。由于本地语言是不安全的（第50项），使用本地方法的应用程序不再能免受内存损坏错误的影响。由于本地语言比Java更依赖于平台，因此使用本地方法的程序不再是可自由移植的。它们【使用本地方法的应用程序】也很难调试。如果你不小心，本地方法可能会降低性能，因为垃圾收集器无法自动化，甚至无法跟踪本机内存使用情况（第8项），并且在进入和退出本地代码时，需要相关的固定开销。最后，需要“胶合代码（glue code）”的本地方法编写起来单调乏味，并且难以阅读。

&emsp;&emsp;总而言之，在使用本地方法之前务必三思。极少数情况下会需要使用本地方法来提高性能。如果你必须要使用本地方法来访问底层的资源，或者本地代码库，也要尽可能少用本地代码，并且要进行全面测试。本地代码中的一个BUG就有可能破坏整个应用程序。