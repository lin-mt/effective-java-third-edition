## 谨慎地使用本地方法

&emsp;&emsp;Java Native Interface (JNI) 允许 Java 应用程序可以调用*本地方法（native method）*，所谓本地方法是指使用*本地程序设计语言（native programming languages）*（比如 C 或者 C++）来编写的方法。从历史上看，本地方法主要有三种用途。它们提供了“访问特定于平台的机制”的能力，比如【访问】注册表。它们还提供了访问遗留代码库的能力，从而可以访问遗留数据（legacy data）。最后，本地方法可以通过本地语言，编写应用程序中注重性能的部分，从而提高系统的性能。

&emsp;&emsp;使用本地方法来访问特定于平台的机制是合法的，但这这么做的必要性并不是很高（but it is seldom necessary）：随着 Java 平台的成熟，它提供了越来越多以前只有在宿主平台上才拥有的特性。例如，在 Java 9 中添加的进程 API，这个 API 提供了访问操作系统的进程的功能。当 Java 中没有可用的等效库时，使用本地方法来使用遗留代码也是合法的。

&emsp;&emsp;**使用本地方法来提高性能的这种做法并不提倡** 。在早期的发行版本中（在 Java 3 之前），这样做往往是很有必要的，但从那时起 JVM 就变得更快了。对于大多数任务，现在可以在 Java 中获得与之相当的性能。例如，当在 1.1 版中添加 java.math 时，BigInteger 依赖于用 C 编写的一个快速的多精度算术库。在 Java 3 中，BigInteger 在 Java 中重新实现，并仔细调整到比原来【依赖于】本地【库】实现【的版本】运行得更快的程度。

&emsp;&emsp;这个故事的一个令人遗憾的结论是 BigInteger 从那以后变化不大，除了 Java 8 中大数字的快速乘法。在那段时间，本机【代码】库的【优化】工作仍在继续，特别是 GNU 多精度算术库（GMP）。现在需要真正高性能多精度算术的 Java 程序猿通过本地方法\[Blum14\]使用 GMP 是合理的。

&emsp;&emsp;使用本地方法具有严重的缺点。由于本地语言是不安全的（第 50 项），使用本地方法的应用程序不再能免受内存损坏错误的影响。由于本地语言比 Java 更依赖于平台，因此使用本地方法的程序不再是可自由移植的。它们【使用本地方法的应用程序】也很难调试。如果你不小心，本地方法可能会降低性能，因为垃圾收集器无法自动化，甚至无法跟踪本机内存使用情况（第 8 项），并且在进入和退出本地代码时，需要相关的固定开销。最后，需要与本地方法进行“耦合的代码（glue code）”编写起来单调乏味，并且难以阅读。

&emsp;&emsp;总而言之，在使用本地方法之前务必三思。极少数情况下会需要使用本地方法来提高性能。如果你必须要使用本地方法来访问底层的资源，或者本地代码库，也要尽可能少用本地代码，并且要进行全面测试。本地代码中的一个 BUG 就有可能破坏整个应用程序。

> - [第 65 项：接口优先于反射机制](https://gitee.com/lin-mt/effective-java-third-edition/blob/master/第09章：通用编程/第65项：接口优先于反射机制.md)
> - [第 67 项：谨慎地进行优化](https://gitee.com/lin-mt/effective-java-third-edition/blob/master/第09章：通用编程/第67项：谨慎地进行优化.md)
