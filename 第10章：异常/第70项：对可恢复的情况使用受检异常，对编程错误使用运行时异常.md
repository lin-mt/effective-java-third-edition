## 对可恢复的情况使用受检异常，对编程错误使用运行时异常

&emsp;&emsp;Java 程序设计语言提供了是三种可抛出结构（throwable）：_受检异常（checked exceptions）_，*运行时异常（ runtime exceptions）*和*错误（error）*。在程序猿之间就存在一些困惑：什么时候适合使用哪种可抛出结构。虽然做决定的界限并不总是那么清晰，但还是有一些一般性的原则提供了强有力的指导。

&emsp;&emsp;在决定使用受检的异常或者未受检的异常时，主要的原则是：**如果期望调用者能够适当地恢复【到正常状态】，对于这种情况就应该使用受检的异常** 。通过抛出受检的异常，强迫调用者在一个 catch 子句中处理该异常，或者将它传播出去。因此，方法中声明要抛出的每个受检的异常，都是对 API 用户的一种潜在的指示：与异常相关联的条件是调用这个方法的一种可能的结果。

&emsp;&emsp;API 的设计者让 API 用户面对受检的异常，以此强制用户从这个异常条件中恢复。用户可以忽视这样的强制要求，只需要捕获异常并忽略即可，但这往往不是个好办法(第 77 项)。

&emsp;&emsp;有两种未受检的可抛出结构：运行时异常和错误。在行为上两者是等同的：它们都是不需要也不应该被捕获的可抛出结构。如果程序抛出未受检的异常或者错误，往往就属于不可恢复的情形，继续执行下去有害无益。如果程序没有捕获到这样的可抛出结构，将会导致当前线程停止（halt），并出现适当的错误消息。

&emsp;&emsp;**用运行时异常来表明编程错误** 。大多数的运行时异常都表示*违反了前提条件（precondition violation）*。违反前提条件仅仅是指因为客户端 API 没有遵守 API 规范建立的约定。例如，数组访问的约定指明了数组的下标值必须在零和数组长度减 1 之间。ArrayIndexOutOfBoundsException 表明这个前提条件被违反了。

&emsp;&emsp;这个建议的一个问题是，你是正在处理可恢复的条件还是编程错误并不总是很清楚（One problem with this advice is that it is not always clear whether you’re dealing with a recoverable conditions or a programming error）。例如，考虑资源耗尽的情况，这可能是由编程错误引起的，例如分配一个不合理的大型数组，或者是由于资源的真正短缺。如果资源耗尽是由于暂时短缺或暂时需求增加造成的，那么这种情况很可能是可以恢复的。有个问题是：API 设计人员判断【导致】资源耗尽的给定实例是否可能允许恢复。如果你认为某个条件可能允许恢复，请使用受检异常; 如果不是，请使用运行时异常。如果不清楚是否可以进行恢复，则可能最好使用未受检异常，原因如第 71 项中所述。

&emsp;&emsp;虽然 Java 语言规范并没有要求，但是按照惯例，错误往往被 JVM 保留用于表示资源不足、约束失败，或者其他使程序无法继续运行的条件。由于这已经是个几乎被普遍接受的惯例，因此最好不要再实现任何新的 Error 子类。因此，**你实现的所有未受检的抛出结构都应该是 RuntimeException 的子类** （直接的或者间接的）。你不仅不应该定义 Error 的子类，而且对于 AssertionError 异常，你也不应该抛出它们【出现 AssertionError 异常的时候要当场处理，将这个异常扼杀在摇篮中！】。

&emsp;&emsp;要想定义一个抛出结构，它不是 Exception、RuntimeException 或 Error 的子类，这也是有可能的。JSL 并没有直接规定这样的抛出结构，而是隐式地指定了：从行为意义上讲它们等同于普通的受检异常（即 Exception 的子类，但不是 RuntimeException 的子类）。那么，什么时候应该使用这样的抛出结构呢？总之，永远也不会用到。它与普通的受检异常相比没有任何益处，只会困扰使用 API 的用户。

&emsp;&emsp;API 设计者经常忘记异常是完全成熟（full-fledged）的对象【不成熟的对象长啥样】，可以在异常中定义任何方法。此类方法的主要用途是提供捕获异常的代码，其中包含有关导致抛出异常的条件的相关信息。在没有这种方法的情况下，有一种已知的方法是：程序员通过解析异常的字符串进而发现附加信息。这是种非常糟糕的做法（第 12 项）。可抛出的类很少指定其字符串表示【的信息】的细节，因此字符串表示【的信息】可能在不同的实现、不同的发布版本中表示不同的信息。因此，解析异常的字符串【得到异常】表示【的信息】的代码可能是不可移植且脆弱的。

&emsp;&emsp;因为受检异常通常表明可恢复的条件，因此对它们来说，提供一个提供信息进而帮助调用者从异常情况中恢复的方法尤其重要。例如，假设由于资金不足而尝试使用礼品卡进行购买时，会抛出受检异常。该异常应该提供一种访问器方法来查询【资金】缺口（shortfall）。这将使得调用者能够将金额转发给购物者。有关此话题的更多信息，请参阅第 75 项。

&emsp;&emsp;总而言之，对于可恢复的情况，使用受检异常；对于程序错误，则使用运行时异常。如果不知道使用哪种的时候，就抛出未受检的异常。不要定义既不是受检异常也不是运行时异常的任何可抛出结构。在你的受检异常中提供方法来帮助恢复【程序】。

> - [第 69 项：只针对异常的情况才使用异常](https://gitee.com/lin-mt/effective-java-third-edition/blob/master/第10章：异常/第69项：只针对异常的情况才使用异常.md)
> - [第 71 项：避免不必要地使用受检异常](https://gitee.com/lin-mt/effective-java-third-edition/blob/master/第10章：异常/第71项：避免不必要地使用受检异常.md)
