### 线程安全性文档化

&emsp;&emsp;当并发使用一个类的方法时，类的行为方式是该类与其客户端建立的约定的重要组成部分。如果这方面的内容你没有在类的文档中记录下来，使用这个类的用户将被迫做出假设。如果这些假设是错误的，这样得到的程序就可能缺少足够的同步（第78项）或者过度同步（第79项）。无论哪种情况，都可能导致严重的错误。

&emsp;&emsp;你可能听到过这样的说法：通过查看文档中是否出现synchronized修饰符，你可以确定一个方法是否是线程安全的。这种说法从几个方面来说都是错误的。在正常的操作中，Javadoc并没有在它的输出中包含synchronized修饰符，是有好的理由的。**因为在一个方法中出现synchronized修饰符，这是个实现细节，并不是API的一部分** 。它并不一定表明这个方法是线程安全的。

&emsp;&emsp;而且，“使用synchronized修饰符声明的存在就足以用文档说明线程的安全性”的这种说法说体现了一种误解，即线程安全是全有或全无的属性。实际上，线程安全性有多种级别。**一个类为了可以被多个线程安全地使用，必须在文档中清楚地说明它所支持的线程安全性级别** 。下面的列表概括了线程安全性的几种级别。这份列表并没有涵盖所有的可能，而只是些常见的情形：

- **不可变的（immutable）** ——这个类的实例是不变的。所以，不需要外部的同步。这样的例子包括String、Long和BigInteger（第17项）。

- **无条件的线程安全（Unconditionally thread-safe）** ——这个类的实例是可变的，但是这个类有着足够的内部同步，所以，它的实例可以被并发使用，无需任何外部同步。其例子包括AtomicLong和ConcurrentHashMap。

- **有条件的线程安全（Conditionally thread-safe）** ——除了有些方法为进行安全的并发使用而需要外部同步之外，这种线程安全级别与无条件的线程安全相同。这样的例子包括Collections.synchronized包装返回的集合，它们的迭代器（iterator）要求外部同步。

- **非线程安全（not thread-safe）** ——这个类的实例是可变的。为了并发地使用它们，客户端必须利用自己选择的外部同步包围每个方法调用（或者调用序列）。这样的例子包括通用的集合实现，例如ArrayList和HashMap。

- **线程对立的（thread-hostile）** ——这个类不能安全地被多个线程并发使用，即使所有的方法调用都被外部同步包围。线程对立的根源通常在于，没有同步地修改静态数据。没有人会有意地编写一个线程对立的类；这种类是因为没有考虑并发性而产生的后果。当发现类或者方法时线程对立的时候，通常会修复或者弃用它。如【原书】第322页所述，在没有内部同步的情况下，第78项中的generateSerialNumber方法将是线程对立的。

&emsp;&emsp;这些分类（除了线程对立的之外）初略对应于《Java Concurrency in Practice》一书中的*线程安全注解（thread safety annotation）*，分别是Immutable、ThreadSafe和 NotThreadSafe \[Goetz06, Appendix A\]。上述分类中无条件和有条件的线程安全类别都涵盖在ThreadSafe注解中了。

&emsp;&emsp;在文档中记录一个有条件的线程安全类要特别小心。你必须指明哪个调用序列需要外部同步，还要指明为了执行这些序列，必须获得哪个锁（极少的情况下是指多个锁）。通常情况下，这是指作用在实例自身上的那把锁，但也有例外。例如，Collextions.synchronizedMap的文档就有这样的说明：

> It is imperative that the user manually synchronize on the returned map when iterating over any of its collection views(当遍历任何被返回Map的集合视图时，用户必须手工对它们进行同步):
> ```java
> Map<K, V> m = Collections.synchronizedMap(new HashMap<>());
> Set<K> s = m.keySet(); // Needn't be in synchronized block
> ...
> synchronized(m) { // Synchronizing on m, not s!
> for (K key : s)
>   key.f();
> }
> ```

&emsp;&emsp;如果没有遵循这样的建议，就可能造成不确定的行为。

&emsp;&emsp;类的线程安全性的描述通常属于类的文档注释，但具有特殊线程安全属性的方法应该在自己的文档注释中描述这些属性。没有必要说明枚举类型的不可变性。除非从返回类型来看已经很明显，否则静态工厂必须在文档中说明被返回对象的线程安全性，如Collections.synchronizedMap（上述）所示。

&emsp;&emsp;当一个类承诺了“使用一个公有可访问的锁对象”时，就意味着允许客户端以原子的方式执行一个方法调用序列，但是，这种灵活性是要付出代价的。并发集合（如ConcurrentHashMap）使用的哪种并发控制，并不能与高性能的内部并发控制相兼容。客户端还可以发起拒绝服务（denial-of service）攻击，它只需要超时地保持公有可访问锁即可。这可能是无意的，也可能是有意的。

&emsp;&emsp;为了避免这种拒绝服务攻击，应该使用一个*私有锁对象（private lock object）*来代替同步的方法（隐含着一个公有可访问锁）：

```java
// Private lock object idiom - thwarts denial-of-service attack
private final Object lock = new Object();
public void foo() {
    synchronized(lock) {
        ...
    }
}
```

&emsp;&emsp;因为这个私有锁对象不能被这个类的客户端程序所访问，所以它们不可能妨碍对象的同步。实际上，我们正是在应用第15项的建议，把锁对象封装在它所同步的对象中。

&emsp;&emsp;注意lock域被声明为final的。这样可以防止您无意中更改其内容，从而导致灾难性的非同步访问（第78项）。我们这是在应用第17项的建议，将lock域的可变性减到最小。**锁定的域应该始终声明为final的** 。无论您使用普通的监视器锁（monitor lock）（如上所示）还是使用java.util.concurrent.locks包中的锁，都是如此。

&emsp;&emsp;这种私有锁对象的习惯用法只能用在*无条件（unconditionally）*的线程安全类上。有条件的线程安全类不能使用这种用法，因为它们必须在文档中说明：在执行某些方法调用序列时，它们的客户端程序必须获得哪把锁。

&emsp;&emsp;私有锁对象习惯用法特别适合用于继承的类（第19项）。如果这样的类要使用它的实例进行锁定，则子类可能很容易在无意中妨碍基类的操作，反之亦然。出于不同的目的而使用相同的锁，子类和基类可能会“相互绊住对方的脚”。这不只是一个理论意义上的问题。例如，这种现象在Thread类上就出现过\[Bloch05, Puzzle 77\]。

&emsp;&emsp;简而言之，每个类都应该利用字斟句酌的说明或者线程安全注解，清楚地在文档中说明它的线程安全属性。synchronized修饰符与这个文档毫无关系。有条件的线程安全类必须在文档中指明“哪个方法调用序列需要外部同步，以及在执行这些序列的时候要获得哪把锁”。如果你编写的是无条件的线程安全类，就应该考虑使用私有锁对象来代替同步的方法。这样可以防止客户端程序和子类的同步干扰，让你能够在后续的版本中灵活地对并发控制采用更加复杂的方法。