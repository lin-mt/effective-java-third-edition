## 其他序列化优先于 Java 序列化

&emsp;&emsp;当序列化在 1997 年被添加到 Java 时，它被认为有点风险的。该方法已经在一种研究语言（Modula-3）中尝试过，但在生产中的语言中从未用过。虽然程序猿承诺在分布式对象上付出点努力得到的成果是很有吸引力的，代价是构造函数是不可见的而且它的 API 和实现之间的界限很模糊，在正确性、性能、安全性和维护方面可能存在问题。支持者认为这些好处【前面的成果】超过了风险，但历史已经证明并不是这样的。

&emsp;&emsp;本书前几版中描述的安全问题与某些人担心的一样严重。2000 年代早期讨论的小漏洞在接下来的十年被转化为严重的漏洞并被利用了，其中包括对旧金山都市交通局市政铁路（SFMTA Muni）的勒索软件攻击，该铁路在 2016 年 11 月关闭整个收费系统两天\[Gallagher16\]。

&emsp;&emsp;序列化的一个基本问题是它的*攻击面（attack surface）*太大而无法保护并且不断增长：通过在 ObjectInputStream 上调用 readObject 方法来反序列化对象数据图（object graphs）。这个方法本质上是一个神奇的构造函数，只要类型实现了 Serializable 接口，就可以在类路径上实例化几乎任何类型的对象。在反序列化字节流的过程中，此方法可以在这些类型中的任何一个类型执行代码，因此这些类的代码都是受攻击的一部分。

&emsp;&emsp;攻击的方向包括 Java 平台库中的类，第三方库（如 Apache Commons Collections）和应用程序本身。即使您遵守所有相关的最佳实践并成功编写无法攻击的可序列化类，您的应用程序仍可能容易受到攻击。引用 CERT 协调中心技术经理 Robert Seacord 的话：

> Java 反序列化是一个明显且存在的危险，因为它直接被应用程序广泛使用，并间接地由 Java 子系统（如 RMI（远程方法调用），JMX（Java 管理扩展）和 JMS（Java 消息系统））广泛使用。不受信任的流的反序列化可能导致远程代码被执行（RCE），拒绝服务（DoS）以及一系列其他漏洞被利用。应用程序即使没有做错也容易受到这些攻击。\[Seacord17\]。

&emsp;&emsp;攻击者和安全研究人员研究 Java 库和常用第三方库中的可序列化类型，查找在反序列化期间调用的执行方法潜在的危险活动。这种方法称为*小工具（gadgets）*。可以一起使用多个小工具来形成*小工具链（gadget chain）*。有时会发现在一个足够强大的小工具链中，只要有机会提交精心设计的字节流进行反序列化，就允许攻击者在底层硬件上执行任意本机代码（native code）。这正是 SFMTA Muni 攻击中发生的事情。这次袭击不是单独的。还有其他的，还会有更多。

&emsp;&emsp;在不使用任何小工具的情况下，你可以轻松地通过反序列化一个需要很长的反序列化时间的短流来发起拒绝服务（denial-of-service）攻击，这种流被称为*反序列化炸弹(deserialization bombs )*\[Svoboda16\]。这是 Wouter Coekaerts 的一个例子，它只使用哈希集和字符串\[Coekaerts15\]：

```java
// Deserialization bomb - deserializing this stream takes forever
static byte[] bomb() {
    Set<Object> root = new HashSet<>();
    Set<Object> s1 = root;
    Set<Object> s2 = new HashSet<>();
    for (int i = 0; i < 100; i++) {
        Set<Object> t1 = new HashSet<>();
        Set<Object> t2 = new HashSet<>();
        t1.add("foo"); // Make t1 unequal to t2
        s1.add(t1); s1.add(t2);
        s2.add(t1); s2.add(t2);
        s1 = t1;
        s2 = t2;
    }
    return serialize(root); // Method omitted for brevity
}
```

&emsp;&emsp;对象数据图由 201 个 HashSet 实例组成，每个实例包含 3 个或更少的对象引用。整个流的长度为 5,744 字节，但是远在你将其反序列化之前就会烧掉太阳【CPU】。问题在于反序列化 HashSet 实例需要计算其元素的哈希码。哈希集合的根的 2 个元素本身是包含 2 个哈希集元素的哈希集，每个哈希集元素包含 2 个哈希集元素，依此类推，深度为 100 个级别。

&emsp;&emsp;那么你能做些什么来抵御这些问题呢？每当您反序列化您不信任的字节流时，您就会打开攻击。**避免序列化漏洞被利用的最佳方法是永远不要反序列化任何东西** 。用 1983 年电影“战争游戏”中名为约书亚的电脑的话来说，“唯一的胜利之举就是不玩。”**在您编写的任何新系统中都没有理由使用 Java 序列化** 。还有其他在对象和字节序列之间进行转换的机制，可以避免 Java 序列化的许多危险，同时提供许多优势，例如跨平台支持，高性能，大型工具生态系统以及广泛的专业知识社区。在本书中，我们将这些机制称为*跨平台结构化数据表示（ cross-platform structured-data representations）*。虽然其他人有时将它们称为序列化系统，但本书避免了这种用法，以防止与 Java 序列化混淆。

&emsp;&emsp;这些【机制】表面特征的共同之处在于它们比 Java 序列化简单得多。它们不支持任意对象数据图的自动序列化和反序列化。相反，它们支持一组由属性-值（attribute-value）组成的简单结构化数据对象。仅支持少数基本数据类型和数组数据类型。这种简单的抽象足以构建极其强大的分布式系统，并且足够简单，可以避免从一开始就困扰 Java 序列化的严重问题。

&emsp;&emsp;领先的跨平台结构化数据表示是 JSON \[JSON\]和 Protocol Buffers，也称为 protobuf \[Protobuf\]。JSON 由 Douglas Crockford 设计用于浏览器-服务器通信，并且 Protocol Buffers 由 Google 设计用于在其服务器之间存储和交换结构化数据。即使这些表示有时被称为*中立语言（language-neutral）*，JSON 最初是为 JavaScript 开发的，而 protobuf 是为 C++开发的; 这两种的表现方式都保留了他们起源的痕迹。

&emsp;&emsp;JSON 和 protobuf 之间最显着的区别是 JSON 是基于文本的，人类可读的，而 protobuf 是二元的，效率更高; 并且 JSON 完全是数据表示，而 protobuf 提供*模式（schemas）*（类型）来记录和执行适当的用法。尽管 protobuf 比 JSON 更有效，但 JSON 对于基于文本的表示非常有效。虽然 protobuf 是二进制表示，但它确实提供了一种代替【二进制的】文本表示，它的用途是用于人类需要【数据具有】可读性的时候（pbtxt）。

&emsp;&emsp;如果您无法完全避免 Java 序列化，可能是因为你需要它在遗留系统的上下文中工作，那么您的下一个最佳选择是**永远不会反序列化不受信任的数据** 。特别是，您永远不应接受来自不受信任来源的 RMI 流量。Java 的官方安全编码指南说“不受信任数据的反序列化本质上是危险的，应该避免【反序列化不受信任的数据】。”这句话设置为大，粗体，斜体，红色类型，它是整个文档中唯一获得此处理的文本\[Java-secure\]。

&emsp;&emsp;如果您无法避免序列化，并且您不确定要反序列化的数据的安全性，请使用 Java 9 中添加的对象反序列化过滤并移植到早期版本（java.io.ObjectInputFilter）。此工具允许您指定一个过滤器，这个过滤器应用在反序列化之前的数据流【也就是要过滤反序列化之前的数据流】。它以类粒度运行，允许您接受或拒绝某些类。默认接受某些类并拒绝具有潜在危险的类的列表称为*黑名单（blacklisting）*；默认情况下拒绝某些类并接受假定安全的类的列表称为*白名单（whitelisting）*。**白名单优先于黑名单** ，因为黑名单只能保护你免受已知的威胁。使用白名单优于使用黑名单，因为黑名单只能保护您免受已知威胁。名为 Serial Whitelist Application Trainer（SWAT）的工具可用于为您的应用程序\[Schneider16\]自动准备白名单。过滤工具还可以保护您免受过多的内存使用和过深的对象数据图，但它不会保护您免受如上所示的序列化炸弹的攻击。

&emsp;&emsp;不幸的是，序列化在 Java 生态系统中仍然普遍存在。如果您要维护基于 Java 序列化的系统，请认真考虑迁移到跨平台的结构化数据表示，即使这可能是一项耗时的工作。实际上，您可能仍然发现自己必须编写或维护可序列化的类。编写一个正确，安全，高效的可序列化类需要非常小心。本章的其余部分提供了有关何时以及如何执行此操作的建议。

&emsp;&emsp;总之，序列化是危险的，应该避免【序列化】。如果您从头开始设计系统，请使用跨平台的结构化数据表示，例如 JSON 或 protobuf。不要反序列化不受信任的数据。如果必须这样做，请使用对象反序列化过滤，但请注意，这不能保证阻止所有的攻击。避免编写可序列化的类。如果你必须这样做，请谨慎行事。

> - [第 84 项：不要依赖于线程调度器](https://gitee.com/lin-mt/effective-java-third-edition/blob/master/第11章：并发/第84项：不要依赖于线程调度器.md)
> - [第 86 项：谨慎地实现 Serializable 接口](https://gitee.com/lin-mt/effective-java-third-edition/blob/master/第12章：序列化/第86项：谨慎地实现Serializable接口.md)
